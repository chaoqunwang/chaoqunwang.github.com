<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Java | 超群的博客]]></title>
  <link href="http://www.wangchaoqun.com/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://www.wangchaoqun.com/"/>
  <updated>2014-01-08T02:31:09-08:00</updated>
  <id>http://www.wangchaoqun.com/</id>
  <author>
    <name><![CDATA[wang chaoqun]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Excel导出工具类]]></title>
    <link href="http://www.wangchaoqun.com/blog/2013/01/01/exceldao-chu-gong-ju-lei/"/>
    <updated>2013-01-01T00:32:42-08:00</updated>
    <id>http://www.wangchaoqun.com/blog/2013/01/01/exceldao-chu-gong-ju-lei</id>
    <content type="html"><![CDATA[<p>前端使用jquery easyui，datagrid添加导出按钮（另外的js逻辑）即可将当前页或所有页数据(支持查询条件的导出)导出到excel，支持office excel 2003和2007+;<br/>
使用apache poi（+ooxml）实现，主要代码片段如下：</p>

<!--more-->


<p>```java
package com.colalife.core.util.excel;</p>

<p>public class ExcelExportUtil {</p>

<pre><code>private static Logger logger = LoggerFactory.getLogger(ExcelExportUtil.class);
private static Map&lt;String, CellStyle&gt; styles;
/**
 * sheetName Excel导出文档里的标签页名，默认为Sheet1
 */
public static final String DEFAULT_SHEET_NAME = "Sheet1";
/**
 * excel导出时文件名，默认为"导出excel.xls"
 */
public static final String DEFAULT_EXCEL_FILE_NAME = "导出excel.xls";

/**
 * Excel导出,sheetName默认为Sheet1
 * @param dataList 数据，可用bean list
 * @param columns 字段和字段显示名的键值对
 */
public static void export(List&lt;?&gt; dataList, Map&lt;String, String&gt; columns, HttpServletResponse response)
        throws IOException {
    String[] fields = columns.keySet().toArray(new String[0]);
    String[] titles = columns.values().toArray(new String[0]);
    export(dataList, fields, titles, response);
}

/**
 * Excel导出,sheetName默认为Sheet1
 * @param dataList 数据，可用bean list
 * @param EasyuiDataGrid 用来获取fields titles 字段和字段显示名的数组
 */
public static void export(List&lt;?&gt; dataList, EasyuiDataGrid dg, HttpServletResponse response)
        throws IOException {
    String[] fields = dg.getFields().split(",");
    String[] titles = dg.getTitles().split(",");
    Workbook excel = ExcelExportUtil.getExcel(dataList, fields, titles);
    ExcelExportUtil.setResponseForExcel(response);
    excel.write(response.getOutputStream());
    response.getOutputStream().flush();
    response.getOutputStream().close();
}

/**
 * Excel导出,sheetName默认为Sheet1
 * @param dataList 数据，可用bean list
 * @param fields titles 字段和字段显示名的数组
 */
public static void export(List&lt;?&gt; dataList, String[] fields, String[] titles, HttpServletResponse response)
        throws IOException {
    Workbook excel = ExcelExportUtil.getExcel(dataList, fields, titles);
    ExcelExportUtil.setResponseForExcel(response);
    excel.write(response.getOutputStream());
    response.getOutputStream().flush();
    response.getOutputStream().close();
}

/**
 * Excel导出的实现,sheetName默认为Sheet1
 * @param data 数据，可用bean list
 * @param columns 字段和字段显示名的键值对
 */
public static Workbook getExcel(List&lt;?&gt; data, Map&lt;String, String&gt; columns) {
    return getExcel(data, DEFAULT_SHEET_NAME, columns);
}

/**
 * Excel导出的实现,sheetName默认为Sheet1
 * @param data 数据，可用bean list
 * @param columns 字段和字段显示名的键值对
 */
public static Workbook getExcel(List&lt;?&gt; data, String[] fields, String[] titles) {
    return getExcel(data, DEFAULT_SHEET_NAME, fields, titles);
}

/**
 * Excel导出的实现
 * @param data 数据，可用bean list
 * @param sheetName 导出文档里的标签页名
 * @param columns 字段和字段显示名的键值对
 */
public static Workbook getExcel(List&lt;?&gt; data, String sheetName, Map&lt;String, String&gt; columns) {
    String[] fields = columns.keySet().toArray(new String[0]);
    String[] titles = columns.values().toArray(new String[0]);
    return getExcel(data, sheetName, fields, titles);
}

/**
 * Excel导出的实现
 * @param data 数据，可用bean list
 * @param sheetName 导出文档里的标签页名
 * @param fields titles 字段和字段显示名的数组
 */
public static Workbook getExcel(List&lt;?&gt; data, String sheetName, String[] fields, String[] titles) {
    Workbook workbook = new HSSFWorkbook();
    //创建所有Cell Style
    createStyles(workbook);
    Sheet sheet = workbook.createSheet(sheetName);
    // 创建第一行,为excel表头
    Row row = sheet.createRow(0);
    // 序号列
    Cell numHeader = row.createCell(0);
    numHeader.setCellValue(new HSSFRichTextString("序号"));
    numHeader.setCellStyle(styles.get("header"));
    for (int i = 1; i &lt;= titles.length; i++) {
        Cell header = row.createCell(i);
        header.setCellValue(new HSSFRichTextString(titles[i - 1]));
        header.setCellStyle(styles.get("header"));
    }
    // 创建其他各数据行
    if (!data.isEmpty()) {
        for (int j = 0; j &lt; data.size(); j++) {
            Object bean = data.get(j);
            Row dataRow = sheet.createRow(j + 1);
            // 序号列
            Cell num = dataRow.createCell(0);
            num.setCellValue(new HSSFRichTextString(String.valueOf(j + 1)));
            num.setCellStyle(styles.get("normal"));
            for (int k = 1; k &lt;= fields.length; k++) {
                Cell cell = dataRow.createCell(k);
                Object value = null;
                boolean isDate = false;
                try {
                    value = PropertyUtils.getSimpleProperty(bean, fields[k - 1]);
                    if (value instanceof Date) {
                        value = DateUtil.formatDate((Date) value);
                        isDate = true;
                    }
                } catch (Exception e) {
                    logger.error("Excel导出，获取属性值异常：" + e.getMessage());
                }
                HSSFRichTextString cellValue = new HSSFRichTextString(ObjectUtils.toString(value));
                cell.setCellValue(cellValue);
                cell.setCellStyle(isDate ? styles.get("dateCell") : styles.get("normal"));
            }
        }
    }
    for (int i = 0; i &lt; titles.length; i++) {
        // 自适应宽度
        sheet.autoSizeColumn(i);
    }
    return workbook;
}

/**
 * excel导出时用到的方法，直接调用
 */
public static void setResponseForExcel(HttpServletResponse response) {
    setResponseForExcel(response, DEFAULT_EXCEL_FILE_NAME);
}

/**
 * excel导出时用到的方法，直接调用
 * @throws UnsupportedEncodingException
 */
public static void setResponseForExcel(HttpServletResponse response, String fileName) {
    response.setContentType("application/vnd.ms-excel;charset=UTF-8");
    try {
        // 解决excel文件乱码问题
        response.setHeader("Content-Disposition", "attachment;filename="
                + new String(fileName.getBytes("GB2312"), "ISO8859-1"));
    } catch (UnsupportedEncodingException e) {
        logger.error("Excel导出，转码异常：" + e.getMessage());
    }
    response.setHeader("Cache-Control", "must-revalidate, post-check=0, pre-check=0");
    response.setHeader("Pragma", "public");
    response.setDateHeader("Expires", 0);
}

private static Map&lt;String, CellStyle&gt; createStyles(Workbook wb) {
    styles = Maps.newHashMap();
    DataFormat df = wb.createDataFormat();

    // --字体设定 --//

    //普通字体
    Font normalFont = wb.createFont();
    normalFont.setFontName("宋体");
    normalFont.setFontHeightInPoints((short) 12);

    //加粗字体
    Font boldFont = wb.createFont();
    boldFont.setFontHeightInPoints((short) 12);
    boldFont.setBoldweight(Font.BOLDWEIGHT_BOLD);

    //蓝色加粗字体
    Font blueBoldFont = wb.createFont();
    blueBoldFont.setFontHeightInPoints((short) 12);
    blueBoldFont.setBoldweight(Font.BOLDWEIGHT_BOLD);
    blueBoldFont.setColor(IndexedColors.BLUE.getIndex());

    // --Cell Style设定-- //
    //普通格式
    CellStyle normalStyle = wb.createCellStyle();
    normalStyle.setFont(normalFont);
    styles.put("normal", normalStyle);

    //标题格式
    CellStyle headerStyle = wb.createCellStyle();
    headerStyle.setFont(boldFont);
    // 指定单元格居中对齐
    headerStyle.setAlignment(HSSFCellStyle.ALIGN_CENTER);
    // 指定单元格垂直居中对齐
    headerStyle.setVerticalAlignment(HSSFCellStyle.VERTICAL_CENTER);
    styles.put("header", headerStyle);

    //日期格式
    CellStyle dateCellStyle = wb.createCellStyle();
    dateCellStyle.setFont(normalFont);
    dateCellStyle.setDataFormat(df.getFormat("yyyy-MM-dd HH:mm:ss"));
</code></pre>

<p>//      setBorder(dateCellStyle);</p>

<pre><code>    styles.put("dateCell", dateCellStyle);

    //数字格式
    CellStyle numberCellStyle = wb.createCellStyle();
    numberCellStyle.setFont(normalFont);
    numberCellStyle.setDataFormat(df.getFormat("#,##0.00"));
    setBorder(numberCellStyle);
    styles.put("numberCell", numberCellStyle);

    //合计列格式
    CellStyle totalStyle = wb.createCellStyle();
    totalStyle.setFont(blueBoldFont);
    totalStyle.setWrapText(true);
    totalStyle.setAlignment(CellStyle.ALIGN_RIGHT);
    setBorder(totalStyle);
    styles.put("total", totalStyle);

    return styles;
}

private static void setBorder(CellStyle style) {
    //设置边框
    style.setBorderRight(CellStyle.BORDER_THIN);
    style.setRightBorderColor(IndexedColors.BLACK.getIndex());

    style.setBorderLeft(CellStyle.BORDER_THIN);
    style.setLeftBorderColor(IndexedColors.BLACK.getIndex());

    style.setBorderTop(CellStyle.BORDER_THIN);
    style.setTopBorderColor(IndexedColors.BLACK.getIndex());

    style.setBorderBottom(CellStyle.BORDER_THIN);
    style.setBottomBorderColor(IndexedColors.BLACK.getIndex());
}
</code></pre>

<p>}</p>

<p>```</p>

<h2>页面调用  </h2>

<p>在相应页面的toolbar里添加导出按钮，调用js function，例如：<br/>
```javascript</p>

<pre><code>function exportData() {
</code></pre>

<p>//      默认导出
//      jsUtil.doDefaultExport(&lsquo;&lt;%=request.getContextPath()%>/core/operlog/export&rsquo;, datagrid);</p>

<p>//      支持查询条件的导出</p>

<pre><code>    var inputs = $("#searchForm input").clone();
    jsUtil.doExport('&lt;%=request.getContextPath()%&gt;/core/operlog/export', datagrid, inputs);
}
</code></pre>

<p><code>
jsUtil里的js逻辑：  
</code>javascript
/<em>*
 * 提交导出form
 </em>/
jsUtil.submitExportForm = function(form) {</p>

<pre><code>form.submit();
form.remove();
</code></pre>

<p>}
/<em>*
 * 导出方法，input为其他查询条件
 </em>/
jsUtil.doExport = function(url, dg, inputs) {</p>

<pre><code>$.messager.defaults = { ok:"当前页数据", cancel:"所有页数据" };
//导出当前页的数据?导出符合条件的所有数据?
$.messager.confirm('导出', '选择导出查询结果里的：', function(isCurrent){
    var form = jsUtil.getDefaultExportForm(url, dg, isCurrent);
    if (inputs != null) {
        // 其他查询条件
        for (var i = 0; i &lt; inputs.length; i++) {
            form.append(inputs[i]);
        }
    }
    jsUtil.submitExportForm(form);
});
$.messager.defaults = { ok:"确定", cancel:"取消" };
</code></pre>

<p>}
/<em>*
 * 导出方法，无其他附加条件，按后台逻辑导出数据
 </em>/
jsUtil.doDefaultExport = function(url, dg) {</p>

<pre><code> var form = jsUtil.getDefaultExportForm(url, dg);
 jsUtil.submitExportForm(form);
</code></pre>

<p>}
/<em>*
 * 构造导出form，默认提交分页信息，列表字段和字段显示名信息
 </em>/
jsUtil.getDefaultExportForm = function(url, dg, isCurrent) {</p>

<pre><code>var form = $("&lt;form&gt;");
form.attr('style', 'display:none');
form.attr('target', '');
form.attr('method', 'post');
form.attr('action', url);
$('body').append(form);
var defaultInputs = jsUtil.getDefaultInputs(url, dg, isCurrent);
for (var i = 0; i &lt; defaultInputs.length; i++) {
    form.append(defaultInputs[i]);
}
return form;
</code></pre>

<p>}
/<em>*
 * 导出form的默认提交参数，包括分页信息，列表字段和字段显示名信息
 </em>/
jsUtil.getDefaultInputs = function(url, dg, isCurrent) {</p>

<pre><code>var inputs = [];
var page = $('&lt;input&gt;');
page.attr('type', 'hidden');
page.attr('name', 'page');
var rows = $('&lt;input&gt;');
rows.attr('type', 'hidden');
rows.attr('name', 'rows');
//导出当前页的数据?导出符合条件的所有数据?
if (isCurrent) {
    page.attr('value', dg.datagrid('options').pageNumber);
    rows.attr('value', dg.datagrid("options").pageSize);
} else {
    page.attr('value', 1);
    rows.attr('value', 2147483647);
}

var sort = $('&lt;input&gt;');
sort.attr('type', 'hidden');
sort.attr('name', 'sort');
sort.attr('value', dg.datagrid('options').sortName);

var order = $('&lt;input&gt;');
order.attr('type', 'hidden');
order.attr('name', 'order');
order.attr('value', dg.datagrid('options').sortOrder);

var fields = $('&lt;input&gt;');
fields.attr('type', 'hidden');
fields.attr('name', 'fields');
fields.attr('value', jsUtil.getFields(dg));

var titles = $('&lt;input&gt;');
titles.attr('type', 'hidden');
titles.attr('name', 'titles');
titles.attr('value', jsUtil.getTitles(dg));

inputs.push(page);
inputs.push(rows);
inputs.push(sort);
inputs.push(order);
inputs.push(fields);
inputs.push(titles);
return inputs;
</code></pre>

<p>};
/<em>*
 * 导出form的列表字段
 </em>/
jsUtil.getFields = function(dg) {</p>

<pre><code>var columns = dg.datagrid("options").columns[0];
var json = '';
if (columns) {
    for (var i = 0; i &lt; columns.length; i++) {
        var field = columns[i].field;
        var title = columns[i].title;
        var hidden = columns[i].hidden;
        if (!hidden) {
            json += field + ','
        }
    }
    if (json != '') {
        json = json.substring(0, json.length - 1);
    }
}
return json;
</code></pre>

<p>};
/<em>*
 * 导出form的列表字段显示名称
 </em>/
jsUtil.getTitles = function(dg) {</p>

<pre><code>var columns = dg.datagrid("options").columns[0];
var json = '';
if (columns) {
    for (var i = 0; i &lt; columns.length; i++) {
        var field = columns[i].field;
        var title = columns[i].title;
        var hidden = columns[i].hidden;
        if (!hidden) {
            json += title + ','
        }
    }
    if (json != '') {
        json = json.substring(0, json.length - 1);
    }
}
return json;
</code></pre>

<p>};</p>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Htmlparser和httpclient解析页面并下载]]></title>
    <link href="http://www.wangchaoqun.com/blog/2012/12/17/shi-yong-htmlparserhe-httpclientjie-xi-ye-mian-bing-xia-zai/"/>
    <updated>2012-12-17T11:05:41-08:00</updated>
    <id>http://www.wangchaoqun.com/blog/2012/12/17/shi-yong-htmlparserhe-httpclientjie-xi-ye-mian-bing-xia-zai</id>
    <content type="html"><![CDATA[<p>如果你想抓取某个网页（如新浪、csdn之类）获取最新资讯列表，或者到某个站点下载文件、图片之类，就需要html解析例如htmlparser,jsoup之类的jar包，下载可用httpclient。如果想更高效率可以搞线程池，抓取解析线程和下载线程，类似消费者和生产者模型（此处不涉及，仅演示使用），代码如下：</p>

<!--more-->


<p>```java</p>

<pre><code>public static Set&lt;String&gt; digLinks(String address) throws Exception {
    Set&lt;String&gt; result = new HashSet&lt;String&gt;();
    URL url = new URL(address);
    Parser parser = new Parser((HttpURLConnection) url.openConnection());
    NodeFilter filter = new HasAttributeFilter("id", "someid");
    NodeList nodes = parser.extractAllNodesThatMatch(filter);
    Node root = nodes.elementAt(0);
    String html = root.getChildren().toHtml();
    parser = Parser.createParser(html, "utf-8");
    nodes = parser.extractAllNodesThatMatch(new TagNameFilter("li"));
    parser = Parser.createParser(html, "utf-8");
    nodes = parser.extractAllNodesThatMatch(new TagNameFilter("a"));
    add(result, nodes);
    return result;
}

private static void add(Set&lt;String&gt; result, NodeList nodes) {
    for (int i = 0; i &lt; nodes.size(); i++) {
        Node child = nodes.elementAt(i);
        if (child instanceof LinkTag) {
            LinkTag linknode = (LinkTag) child;
            String href = linknode.getLink();
            result.add(href);
        }
    }
}
</code></pre>

<p>```</p>

<h2>httpclient 下载  </h2>

<p>```java</p>

<pre><code>/**
 * 读出文件中的url，连接下载保存
 * @param file
 */
public static void doSave(String file) {
    List&lt;String&gt; files = FileUtil.readLines(file);
    for (String url : files) {
        String fileName = StringUtils.substringAfterLast(url, "/");
        download(url, fileName);
    }
}

private static void download(String url, String fileName) {
    OutputStream out = null;
    InputStream in = null;
    HttpURLConnection connection = null;
    URL server = null;
    try {
        server = new URL(url);
        connection = (HttpURLConnection) server.openConnection();
        connection.connect();
        in = connection.getInputStream();

        File file = new File(dir + fileName);
        if (file.exists()) {
            return;
        }
        out = new FileOutputStream(file);
        int b = in.read();
        while (b != -1) {
            out.write(b);
            b = in.read();
        }
        in.close();
        out.close();
    } catch (Exception e) {
    }
}
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[测试Hibernate动态添加实体类]]></title>
    <link href="http://www.wangchaoqun.com/blog/2012/09/27/ce-shi-hibernatedong-tai-tian-jia-wei-pei-zhi-de-shi-ti-lei/"/>
    <updated>2012-09-27T16:54:33-07:00</updated>
    <id>http://www.wangchaoqun.com/blog/2012/09/27/ce-shi-hibernatedong-tai-tian-jia-wei-pei-zhi-de-shi-ti-lei</id>
    <content type="html"><![CDATA[<p>大家知道通过hibernate cfg或和spring集成的配置里，可用packagesToScan或mapping*之类声明实体类；但有需求可能要在某个项目中编码式加载实体类（例如某个不常用的或特定用户的实体类，并未事先配置），然后进行增删改查操作。下面代码配合spring test framework做了测试（注：hibernate升级到了4.3.final，与4.2有不同，spring3或4测试通过）：<!--more-->
```java
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = { &ldquo;/spring-hibernate.xml&rdquo; })
public class ConfigurationTest extends AbstractJUnit4SpringContextTests {</p>

<pre><code>public static final String session_factory = "sessionFactory";
// 值得注意: org.springframework.beans.factory.FactoryBean that creates a Hibernate org.hibernate.SessionFactory
public static final String local_session_factory = "&amp;sessionFactory";

@Test
public void sessionFactoryAndFactoryBean() throws ClassNotFoundException {
    SessionFactory sessionFactory = (SessionFactory) applicationContext.getBean(session_factory);
    Map&lt;String, ClassMetadata&gt; meta = sessionFactory.getAllClassMetadata();
    for (Entry&lt;String, ClassMetadata&gt; each : meta.entrySet()) {
        ClassMetadata value = each.getValue();
        System.out.println("entity name:" + value.getEntityName());
    }

    LocalSessionFactoryBean sessionFactoryBean = (LocalSessionFactoryBean) applicationContext.getBean(local_session_factory);

    Configuration config = sessionFactoryBean.getConfiguration();
    config.addAnnotatedClass(User.class);
    ServiceRegistry serviceRegistry = new StandardServiceRegistryBuilder().applySettings(config.getProperties()).build();
    SessionFactory newSessionFactory = config.buildSessionFactory(serviceRegistry);
    Session session = newSessionFactory.openSession();

    User user = new User();
    user.setName("username");
    session.save(user);
    session.flush();

    user = (User) session.get(User.class, user.getId());
    session.close();
    System.out.println("------" + user.getId());
    System.out.println("------" + user.getName());

    Iterator&lt;Table&gt; mappings = config.getTableMappings();
    while (mappings.hasNext()) {
        Table each = mappings.next();
        System.out.println("table name:" + each.getName());
    }

}
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[9种排序算法的java实现]]></title>
    <link href="http://www.wangchaoqun.com/blog/2010/08/08/jiu-zhong-pai-xu-suan-fa-de-javashi-xian/"/>
    <updated>2010-08-08T22:09:09-07:00</updated>
    <id>http://www.wangchaoqun.com/blog/2010/08/08/jiu-zhong-pai-xu-suan-fa-de-javashi-xian</id>
    <content type="html"><![CDATA[<p>使用枚举类型存入各算法和接口实现，main方法打印排序后的数组，也可以加入nanotime、currentTimeMillis测试效率，但可能数组太小不明显</p>

<p><code>java
package comcolalife.demo.sort;
import java.util.Arrays;
/**
 * 冒择入希快(快改进)归(归改进)堆：9种排序算法的java实现
 * @author wangchaoqun
 */
public class SortTest {
</code></p>

<!--more-->


<p>```java</p>

<pre><code>public static void main(String[] args) {
    int[] original = { 1, 3, 1, 10, 4, 8, 5, 21, 43, 29, 53 };
    // 执行排序算法
    for (Sorts each : Sorts.values()) {
        System.out.print(each.name() + "    ");
        int[] data = Arrays.copyOf(original, original.length);
        each.impl().sort(data);
        print(data);
    }
    // java.util.Arrays类使用调优的快速排序法
    Arrays.sort(original);
    print(original);
}

public static void print(int[] data) {
    for (int each : data) {
        System.out.print(each + " ");
    }
    System.out.println();
}
</code></pre>

<p>}</p>

<p>/<em>*
 * 插入排序算法
 </em>/
class InsertSort implements Sort {</p>

<pre><code>public void sort(int[] data) {
    for (int i = 1; i &lt; data.length; i++) {
        for (int j = i; (j &gt; 0) &amp;&amp; (data[j] &lt; data[j - 1]); j--) {
            SortUtil.swap(data, j, j - 1);
        }
    }
}
</code></pre>

<p>}</p>

<p>/<em>*
 * 冒泡排序算法
 </em>/
class BubbleSort implements Sort {</p>

<pre><code>public void sort(int[] data) {
    for (int i = 0; i &lt; data.length; i++) {
        for (int j = data.length - 1; j &gt; i; j--) {
            if (data[j] &lt; data[j - 1]) {
                SortUtil.swap(data, j, j - 1);
            }
        }
    }
}
</code></pre>

<p>}</p>

<p>/<em>*
 * 选择排序算法
 </em>/
class SelectionSort implements Sort {</p>

<pre><code>public void sort(int[] data) {
    for (int i = 0; i &lt; data.length; i++) {
        int lowIndex = i;
        for (int j = data.length - 1; j &gt; i; j--) {
            if (data[j] &lt; data[lowIndex]) {
                lowIndex = j;
            }
        }
        SortUtil.swap(data, i, lowIndex);
    }
}
</code></pre>

<p>}</p>

<p>/<em>*
 * 希尔排序算法
 </em>/
class ShellSort implements Sort {</p>

<pre><code>public void sort(int[] data) {
    for (int i = data.length / 2; i &gt; 2; i /= 2) {
        for (int j = 0; j &lt; i; j++) {
            insertSort(data, j, i);
        }
    }
    insertSort(data, 0, 1);
}

private void insertSort(int[] data, int start, int inc) {
    for (int i = start + inc; i &lt; data.length; i += inc) {
        for (int j = i; (j &gt;= inc) &amp;&amp; (data[j] &lt; data[j - inc]); j -= inc) {
            SortUtil.swap(data, j, j - inc);
        }
    }
}
</code></pre>

<p>}</p>

<p>/<em>*
 * 快速排序算法
 </em>/
class QuickSort implements Sort {</p>

<pre><code>public void sort(int[] data) {
    quickSort(data, 0, data.length - 1);
}

private void quickSort(int[] data, int first, int last) {
    if (first &gt;= last) {
        return;
    }

    int pivot = partition(data, first, last, first);
    quickSort(data, first, pivot - 1);// 对左半段排序
    quickSort(data, pivot + 1, last);// 对右半段排序

}

private int partition(int[] data, int first, int last, int pivot) {
    while (true) {
        while (data[++first] &lt; data[pivot])
            ;
        while (data[--last] &gt; data[pivot])
            ;
        if (first &gt;= last) {
            break;
        }
        SortUtil.swap(data, first, last);
    }
    SortUtil.swap(data, last, pivot);
    return last;
}
</code></pre>

<p>}</p>

<p>/<em>*
 * 改进的快速排序算法
 </em>/
class ImprovedQuickSort implements Sort {</p>

<pre><code>private static int MAX_STACK_SIZE = 4096;
private static int THRESHOLD = 10;

public void sort(int[] data) {
    int[] stack = new int[MAX_STACK_SIZE];

    int top = -1;
    int pivot;
    int pivotIndex, l, r;

    stack[++top] = 0;
    stack[++top] = data.length - 1;

    while (top &gt; 0) {
        int j = stack[top--];
        int i = stack[top--];

        pivotIndex = (i + j) / 2;
        pivot = data[pivotIndex];

        SortUtil.swap(data, pivotIndex, j);

        // partition
        l = i - 1;
        r = j;
        do {
            while (data[++l] &lt; pivot)
                ;
            while ((r != 0) &amp;&amp; (data[--r] &gt; pivot))
                ;
            SortUtil.swap(data, l, r);
        } while (l &lt; r);
        SortUtil.swap(data, l, r);
        SortUtil.swap(data, l, j);

        if ((l - i) &gt; THRESHOLD) {
            stack[++top] = i;
            stack[++top] = l - 1;
        }
        if ((j - l) &gt; THRESHOLD) {
            stack[++top] = l + 1;
            stack[++top] = j;
        }
    }
    insertSort(data);
}

private void insertSort(int[] data) {
    for (int i = 1; i &lt; data.length; i++) {
        for (int j = i; (j &gt; 0) &amp;&amp; (data[j] &lt; data[j - 1]); j--) {
            SortUtil.swap(data, j, j - 1);
        }
    }
}
</code></pre>

<p>}</p>

<p>/<em>*
 * 归并排序算法
 </em>/
class MergeSort implements Sort {</p>

<pre><code>public void sort(int[] data) {
    int[] temp = new int[data.length];
    mergeSort(data, temp, 0, data.length - 1);
}

private void mergeSort(int[] data, int[] temp, int left, int right) {
    if (left == right) {
        return;
    }
    int mid = (left + right) / 2;
    mergeSort(data, temp, left, mid);
    mergeSort(data, temp, mid + 1, right);
    for (int i = left; i &lt;= right; i++) {
        temp = Arrays.copyOf(data, data.length);
    }
    int i1 = left;
    int i2 = mid + 1;
    for (int cur = left; cur &lt;= right; cur++) {
        if (i1 == mid + 1) {
            data[cur] = temp[i2++];
        } else if (i2 &gt; right) {
            data[cur] = temp[i1++];
        } else if (temp[i1] &lt; temp[i2]) {
            data[cur] = temp[i1++];
        } else {
            data[cur] = temp[i2++];
        }
    }
}
</code></pre>

<p>}</p>

<p>/<em>*
 * 改进的归并排序算法
 </em>/
class ImprovedMergeSort implements Sort {</p>

<pre><code>private static final int THRESHOLD = 10;

public void sort(int[] data) {
    int[] temp = new int[data.length];
    mergeSort(data, temp, 0, data.length - 1);
}

private void mergeSort(int[] data, int[] temp, int left, int right) {
    int i, j, k;
    int mid = (left + right) / 2;
    if (left == right) {
        return;
    }
    if ((mid - left) &gt;= THRESHOLD) {
        mergeSort(data, temp, left, mid);
    } else {
        insertSort(data, left, mid - left + 1);
    }
    if ((right - mid) &gt; THRESHOLD) {
        mergeSort(data, temp, mid + 1, right);
    } else {
        insertSort(data, mid + 1, right - mid);
    }
    for (i = left; i &lt;= mid; i++) {
        temp = Arrays.copyOf(data, data.length);
    }
    for (j = 1; j &lt;= right - mid; j++) {
        temp[right - j + 1] = data[j + mid];
    }
    int a = temp[left];
    int b = temp[right];
    for (i = left, j = right, k = left; k &lt;= right; k++) {
        if (a &lt; b) {
            data[k] = temp[i++];
            a = temp[i];
        } else {
            data[k] = temp[j--];
            b = temp[j];
        }
    }
}

private void insertSort(int[] data, int start, int len) {
    for (int i = start + 1; i &lt; start + len; i++) {
        for (int j = i; (j &gt; start) &amp;&amp; data[j] &lt; data[j - 1]; j--) {
            SortUtil.swap(data, j, j - 1);
        }
    }
}
</code></pre>

<p>}</p>

<p>/<em>*
 * 堆排序算法
 </em>/
class HeapSort implements Sort {</p>

<pre><code>public void sort(int[] data) {
    MaxHeap h = new MaxHeap();
    h.init(data);
    for (int i = 0; i &lt; data.length; i++) {
        h.remove();
    }
    System.arraycopy(h.queue, 1, data, 0, data.length);
}

private static class MaxHeap {
    void init(int[] data) {
        this.queue = new int[data.length + 1];
        for (int i = 0; i &lt; data.length; i++) {
            queue[++size] = data[i];
            fixUp(size);
        }
    }

    private int size = 0;
    private int[] queue;

    public void remove() {
        SortUtil.swap(queue, 1, size--);
        fixDown(1);
    }

    // fixdown
    private void fixDown(int k) {
        int j;
        while ((j = k &lt;&lt; 1) &lt;= size) {
            if (j &lt; size &amp;&amp; queue[j] &lt; queue[j + 1]) {
                j++;
            }
            if (queue[k] &gt; queue[j]) { // 不用交换
                break;
            }
            SortUtil.swap(queue, j, k);
            k = j;
        }
    }

    private void fixUp(int k) {
        while (k &gt; 1) {
            int j = k &gt;&gt; 1;
            if (queue[j] &gt; queue[k]) {
                break;
            }
            SortUtil.swap(queue, j, k);
            k = j;
        }
    }

}
</code></pre>

<p>}</p>

<p>/<em>*
 * 排序算法接口
 </em>/
interface Sort {</p>

<pre><code>public void sort(int[] data);
</code></pre>

<p>}</p>

<p>/<em>*
 * 排序算法枚举
 </em>/
enum Sorts {</p>

<pre><code>INSERT() {
    public Sort impl() {
        return new InsertSort();
    }
},
BUBBLE() {
    public Sort impl() {
        return new BubbleSort();
    }
},
SELECTION() {
    public Sort impl() {
        return new SelectionSort();
    }
},
SHELL() {
    public Sort impl() {
        return new ShellSort();
    }
},
QUICK() {
    public Sort impl() {
        return new QuickSort();
    }
},
IMPROVED_QUICK() {
    public Sort impl() {
        return new ImprovedQuickSort();
    }
},
MERGE() {
    public Sort impl() {
        return new MergeSort();
    }
},
IMPROVED_MERGE() {
    public Sort impl() {
        return new ImprovedMergeSort();
    }
},
HEAP() {
    public Sort impl() {
        return new HeapSort();
    }
};

public abstract Sort impl();
</code></pre>

<p>}</p>

<p>/<em>*
 * 排序算法工具类
 </em>/
class SortUtil {</p>

<pre><code>public static void swap(int[] data, int i, int j) {
    int temp = data[i];
    data[i] = data[j];
    data[j] = temp;
}

public static void print(int[] data) {
    for (int each : data) {
        System.out.print(each + " ");
    }
    System.out.println();
}
</code></pre>

<p>}</p>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[转]有挑战性的JAVA程序员面试32问]]></title>
    <link href="http://www.wangchaoqun.com/blog/2008/03/02/zhuan-cheng-xu-ren-sheng-you-tiao-zhan-xing-de-javacheng-xu-yuan-mian-shi-32wen/"/>
    <updated>2008-03-02T18:01:02-08:00</updated>
    <id>http://www.wangchaoqun.com/blog/2008/03/02/zhuan-cheng-xu-ren-sheng-you-tiao-zhan-xing-de-javacheng-xu-yuan-mian-shi-32wen</id>
    <content type="html"><![CDATA[<p><a href="http://tech.ccidnet.com/art/3539/20080228/1374267_1.html" target="_blank">来自赛迪网</a><br/>
   第一，谈谈final， finally， finalize的区别。</p>

<p>　　第二，Anonymous Inner Class （匿名内部类） 是否可以extends（继承）其它类，是否可以implements（实现）interface（接口）？</p>

<p>　　第三，Static Nested Class 和 Inner Class的不同，说得越多越好（面试题有的很笼统）。</p>

<p>　　第四，&amp;和&amp;&amp;的区别。</p>

<!--more-->


<p>　　第五，HashMap和Hashtable的区别。</p>

<p>　　第六，Collection 和 Collections的区别。</p>

<p>　　第七，什么时候用assert.</p>

<p>　　第八，GC是什么？ 为什么要有GC？</p>

<p>　　第九，String s = new String（"xyz"）；创建了几个String Object？</p>

<p>　　第十，Math.round（11.5）等於多少？ Math.round（-11.5）等於多少？</p>

<p>　　第十一，short s1 = 1； s1 = s1 + 1；有什么错？ short s1 = 1； s1 += 1；有什么错？</p>

<p>　　第十二，sleep（） 和 wait（） 有什么区别？</p>

<p>　　第十三，Java有没有goto？</p>

<p>　　第十四，数组有没有length（）这个方法？ String有没有length（）这个方法？</p>

<p>　　第十五，Overload和Override的区别。Overloaded的方法是否可以改变返回值的类型？</p>

<p>　　第十六，Set里的元素是不能重复的，那么用什么方法来区分重复与否呢？ 是用==还是equals（）？ 它们有何区别？</p>

<p>　　第十七，给我一个你最常见到的runtime exception.</p>

<p>　　第十八，error和exception有什么区别？</p>

<p>　　第十九，List， Set， Map是否继承自Collection接口？</p>

<p>　　第二十，abstract class和interface有什么区别？</p>

<p>　　第二十一，abstract的method是否可同时是static，是否可同时是native，是否可同时是synchronized？</p>

<p>　　第二十二，接口是否可继承接口？ 抽象类是否可实现（implements）接口？ 抽象类是否可继承实体类（concrete class）？</p>

<p>　　第二十三，启动一个线程是用run（）还是start（）？</p>

<p>　　第二十四，构造器Constructor是否可被override？</p>

<p>　　第二十五，是否可以继承String类？</p>

<p>　　第二十六，当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法？</p>

<p>　　第二十七，try {}里有一个return语句，那么紧跟在这个try后的finally {}里的code会不会被执行，什么时候被执行，在return前还是后？</p>

<p>　　第二十八，编程题： 用最有效率的方法算出2乘以8等於几？</p>

<p>　　第二十九，两个对象值相同（x.equals（y） == true），但却可有不同的hash code，这句话对不对？</p>

<p>　　第三十，当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递？</p>

<p>　　第三十一，swtich是否能作用在byte上，是否能作用在long上，是否能作用在String上？</p>

<p>　　第三十二，编程题： 写一个Singleton出来。</p>

<p>　　以下是答案</p>

<p>　　第一，谈谈final， finally， finalize的区别。</p>

<p>　　final?修饰符（关键字）如果一个类被声明为final，意味着它不能再派生出新的子类，不能作为父类被继承。因此一个类不能既被声明为 abstract的，又被声明为final的。将变量或方法声明为final，可以保证它们在使用中不被改变。被声明为final的变量必须在声明时给定初值，而在以后的引用中只能读取，不可修改。被声明为final的方法也同样只能使用，不能重载finally?再异常处理时提供 finally 块来执行任何清除操作。如果抛出一个异常，那么相匹配的 catch 子句就会执行，然后控制就会进入 finally 块（如果有的话）。</p>

<p>　　finalize?方法名。Java 技术允许使用 finalize（） 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。它是在 Object 类中定义的，因此所有的类都继承了它。子类覆盖 finalize（） 方法以整理系统资源或者执行其他清理工作。finalize（） 方法是在垃圾收集器删除对象之前对这个对象调用的。</p>

<p>　　第二，Anonymous Inner Class （匿名内部类） 是否可以extends（继承）其它类，是否可以implements（实现）interface（接口）？</p>

<p>　　匿名的内部类是没有名字的内部类。不能extends（继承） 其它类，但一个内部类可以作为一个接口，由另一个内部类实现。</p>

<p>　　第三，Static Nested Class 和 Inner Class的不同，说得越多越好（面试题有的很笼统）。</p>

<p>　　Nested Class （一般是C++的说法），Inner Class （一般是JAVA的说法）。Java内部类与C++嵌套类最大的不同就在于是否有指向外部的引用上。具体可见http： //www.frontfree.net/articles/services/view.asp？id=704&amp;page=1注： 静态内部类（Inner Class）意味着1创建一个static内部类的对象，不需要一个外部类对象，2不能从一个static内部类的一个对象访问一个外部类对象</p>

<p>　　第四，&amp;和&amp;&amp;的区别。</p>

<p>　　&amp;是位运算符。&amp;&amp;是布尔逻辑运算符。</p>

<p>　　第五，HashMap和Hashtable的区别。</p>

<p>　　都属于Map接口的类，实现了将惟一键映射到特定的值上。</p>

<p>　　HashMap 类没有分类或者排序。它允许一个 null 键和多个 null 值。</p>

<p>　　Hashtable 类似于 HashMap，但是不允许 null 键和 null 值。它也比 HashMap 慢，因为它是同步的。</p>

<p>　　第六，Collection 和 Collections的区别。</p>

<p>　　Collections是个java.util下的类，它包含有各种有关集合操作的静态方法。</p>

<p>　　Collection是个java.util下的接口，它是各种集合结构的父接口。</p>

<p>　　第七，什么时候用assert.断言是一个包含布尔表达式的语句，在执行这个语句时假定该表达式为 true.如果表达式计算为 false，那么系统会报告一个 AssertionError.它用于调试目的：assert（a > 0）； // throws an AssertionError if a &lt;= 0断言可以有两种形式：assert Expression1 ；assert Expression1 ： Expression2 ；Expression1 应该总是产生一个布尔值。</p>

<p>　　Expression2 可以是得出一个值的任意表达式。这个值用于生成显示更多调试信息的 String 消息。</p>

<p>　　断言在默认情况下是禁用的。要在编译时启用断言，需要使用 source 1.4 标记：javac -source 1.4 Test.java要在运行时启用断言，可使用 -enableassertions 或者 -ea 标记。</p>

<p>　　要在运行时选择禁用断言，可使用 -da 或者 -disableassertions 标记。</p>

<p>　　要系统类中启用断言，可使用 -esa 或者 -dsa 标记。还可以在包的基础上启用或者禁用断言。</p>

<p>　　可以在预计正常情况下不会到达的任何位置上放置断言。断言可以用于验证传递给私有方法的参数。不过，断言不应该用于验证传递给公有方法的参数，因为不管是否启用了断言，公有方法都必须检查其参数。不过，既可以在公有方法中，也可以在非公有方法中利用断言测试后置条件。另外，断言不应该以任何方式改变程序的状态。</p>

<p>　　第八，GC是什么？ 为什么要有GC？ （基础）。</p>

<p>　　GC是垃圾收集器。Java 程序员不用担心内存管理，因为垃圾收集器会自动进行管理。要请求垃圾收集，可以调用下面的方法之一：System.gc（）</p>

<p>　　Runtime.getRuntime（）。gc（）</p>

<p>　　第九，String s = new String（"xyz"）；创建了几个String Object？</p>

<p>　　两个对象，一个是“xyx”，一个是指向“xyx”的引用对象s.</p>

<p>　　第十，Math.round（11.5）等於多少？ Math.round（-11.5）等於多少？</p>

<p>　　Math.round（11.5）返回（long）12，Math.round（-11.5）返回（long）-11；</p>

<p>　　第十一，short s1 = 1； s1 = s1 + 1；有什么错？ short s1 = 1； s1 += 1；有什么错？</p>

<p>　　short s1 = 1； s1 = s1 + 1；有错，s1是short型，s1+1是int型，不能显式转化为short型。可修改为s1 =（short）（s1 + 1） .short s1 = 1； s1 += 1正确。</p>

<p>　　第十二，sleep（） 和 wait（） 有什么区别？ 搞线程的最爱sleep（）方法是使线程停止一段时间的方法。在sleep 时间间隔期满后，线程不一定立即恢复执行。这是因为在那个时刻，其它线程可能正在运行而且没有被调度为放弃执行，除非（a）“醒来”的线程具有更高的优先级（b）正在运行的线程因为其它原因而阻塞。</p>

<p>　　wait（）是线程交互时，如果线程对一个同步对象x 发出一个wait（）调用，该线程会暂停执行，被调对象进入等待状态，直到被唤醒或等待时间到。</p>

<p>　　第十三，Java有没有goto？</p>

<p>　　Goto?java中的保留字，现在没有在java中使用。</p>

<p>　　第十四，数组有没有length（）这个方法？ String有没有length（）这个方法？</p>

<p>　　数组没有length（）这个方法，有length的属性。</p>

<p>　　String有有length（）这个方法。</p>

<p>　　第十五，Overload和Override的区别。Overloaded的方法是否可以改变返回值的类型？</p>

<p>　　方法的重写Overriding和重载Overloading是Java多态性的不同表现。重写Overriding是父类与子类之间多态性的一种表现，重载Overloading是一个类中多态性的一种表现。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 （Overriding）。子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被“屏蔽”了。如果在一个类中定义了多个同名的方法，它们或有不同的参数个数或有不同的参数类型，则称为方法的重载（Overloading）。Overloaded的方法是可以改变返回值的类型。</p>

<p>　　第十六，Set里的元素是不能重复的，那么用什么方法来区分重复与否呢？ 是用==还是equals（）？ 它们有何区别？</p>

<p>　　Set里的元素是不能重复的，那么用iterator（）方法来区分重复与否。equals（）是判读两个Set是否相等。</p>

<p>　　equals（）和==方法决定引用值是否指向同一对象equals（）在类中被覆盖，为的是当两个分离的对象的内容和类型相配的话，返回真值。</p>

<p>　　第十七，给我一个你最常见到的runtime exception. ArithmeticException， ArrayStoreException， BufferOverflowException， BufferUnderflowException， CannotRedoException， CannotUndoException， ClassCastException， CMMException， ConcurrentModificationException， DOMException， EmptyStackException， IllegalArgumentException， IllegalMonitorStateException， IllegalPathStateException， IllegalStateException，ImagingOpException， IndexOutOfBoundsException， MissingResourceException， NegativeArraySizeException， NoSuchElementException， NullPointerException， ProfileDataException， ProviderException， RasterFormatException， SecurityException， SystemException， UndeclaredThrowableException， UnmodifiableSetException， UnsupportedOperationException</p>

<p>　　第十八，error和exception有什么区别？</p>

<p>　　error 表示恢复不是不可能但很困难的情况下的一种严重问题。比如说内存溢出。不可能指望程序能处理这样的情况。</p>

<p>　　exception 表示一种设计或实现问题。也就是说，它表示如果程序运行正常，从不会发生的情况。</p>

<p>　　第十九，List， Set， Map是否继承自Collection接口？</p>

<p>　　List，Set是</p>

<p>　　Map不是</p>

<p>　　第二十，abstract class和interface有什么区别？</p>

<p>　　声明方法的存在而不去实现它的类被叫做抽象类（abstract class），它用于要创建一个体现某些基本行为的类，并为该类声明方法，但不能在该类中实现该类的情况。不能创建abstract 类的实例。然而可以创建一个变量，其类型是一个抽象类，并让它指向具体子类的一个实例。不能有抽象构造函数或抽象静态方法。Abstract 类的子类为它们父类中的所有抽象方法提供实现，否则它们也是抽象类为。取而代之，在子类中实现该方法。知道其行为的其它类可以在类中实现这些方法。</p>

<p>　　接口（interface）是抽象类的变体。在接口中，所有方法都是抽象的。多继承性可通过实现这样的接口而获得。接口中的所有方法都是抽象的，没有一个有程序体。接口只可以定义static final成员变量。接口的实现与子类相似，除了该实现类不能从接口定义中继承行为。当类实现特殊接口时，它定义（即将程序体给予）所有这种接口的方法。然后，它可以在实现了该接口的类的任何对象上调用接口的方法。由于有抽象类，它允许使用接口名作为引用变量的类型。通常的动态联编将生效。引用可以转换到接口类型或从接口类型转换，instanceof 运算符可以用来决定某对象的类是否实现了接口。</p>

<p>　　第二十一，abstract的method是否可同时是static，是否可同时是native，是否可同时是synchronized？</p>

<p>　　都不能</p>

<p>　　第二十二，接口是否可继承接口？ 抽象类是否可实现（implements）接口？ 抽象类是否可继承实体类（concrete class）？</p>

<p>　　接口可以继承接口。抽象类可以实现（implements）接口，抽象类是否可继承实体类，但前提是实体类必须有明确的构造函数。</p>

<p>　　第二十三，启动一个线程是用run（）还是start（）？</p>

<p>　　启动一个线程是调用start（）方法，使线程所代表的虚拟处理机处于可运行状态，这意味着它可以由JVM调度并执行。这并不意味着线程就会立即运行。run（）方法可以产生必须退出的标志来停止一个线程。</p>

<p>　　第二十四，构造器Constructor是否可被override？</p>

<p>　　构造器Constructor不能被继承，因此不能重写Overriding，但可以被重载Overloading.</p>

<p>　　第二十五，是否可以继承String类？</p>

<p>　　String类是final类故不可以继承。</p>

<p>　　第二十六，当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法？</p>

<p>　　不能，一个对象的一个synchronized方法只能由一个线程访问。</p>

<p>　　第二十七，try {}里有一个return语句，那么紧跟在这个try后的finally {}里的code会不会被执行，什么时候被执行，在return前还是后？</p>

<p>　　会执行，在return前执行。</p>

<p>　　第二十八，编程题： 用最有效率的方法算出2乘以8等於几？</p>

<p>　　有C背景的程序员特别喜欢问这种问题。</p>

<p>　　2 &lt;&lt; 3</p>

<p>　　第二十九，两个对象值相同（x.equals（y） == true），但却可有不同的hash code，这句话对不对？</p>

<p>　　不对，有相同的hash code.</p>

<p>　　第三十，当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递？</p>

<p>　　是值传递。Java 编程语言只由值传递参数。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的内容可以在被调用的方法中改变，但对象的引用是永远不会改变的。</p>

<p>　　第三十一，swtich是否能作用在byte上，是否能作用在long上，是否能作用在String上？</p>

<p>　　switch（expr1）中，expr1是一个整数表达式。因此传递给 switch 和 case 语句的参数应该是 int、 short、 char 或者 byte.long，string 都不能作用于swtich.</p>

<p>　　第三十二，编程题： 写一个Singleton出来。</p>

<p>　　Singleton模式主要作用是保证在Java应用程序中，一个类Class只有一个实例存在。</p>

<p>　　一般Singleton模式通常有几种种形式：第一种形式： 定义一个类，它的构造函数为private的，它有一个static的private的该类变量，在类初始化时实例话，通过一个public的getInstance方法获取对它的引用，继而调用其中的方法。</p>

<p>　　public class Singleton { private Singleton（）{} //在自己内部定义自己一个实例，是不是很奇怪？</p>

<p>　　//注意这是private 只供内部调用private static Singleton instance = new Singleton（）；//这里提供了一个供外部访问本class的静态方法，可以直接访问public static Singleton getInstance（） { return instance；}第二种形式：public class Singleton { private static Singleton instance = null；public static synchronized Singleton getInstance（） { //这个方法比上面有所改进，不用每次都进行生成对象，只是第一次//使用时生成实例，提高了效率！</p>

<p>　　if （instance==null）</p>

<p>　　instance＝new Singleton（）；return instance； 　　} }其他形式：定义一个类，它的构造函数为private的，所有方法为static的。</p>

<p>　　一般认为第一种形式要更加安全些第三十三 Hashtable和HashMap Hashtable继承自Dictionary类，而HashMap是Java1.2引进的Map interface的一个实现</p>

<p>　　HashMap允许将null作为一个entry的key或者value，而Hashtable不允许</p>

<p>　　还有就是，HashMap把Hashtable的contains方法去掉了，改成containsvalue和containsKey.因为contains方法容易让人引起误解。</p>

<p>　　最大的不同是，Hashtable的方法是Synchronize的，而HashMap不是，在多个线程访问Hashtable时，不需要自己为它的方法实现同步，而HashMap就必须为之提供外同步。</p>

<p>　　Hashtable和HashMap采用的hash/rehash算法都大概一样，所以性能不会有很大的差异。</p>
]]></content>
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[文章分类：架构 | 超群的博客]]></title>
  <link href="http://wangchaoqun.com/blog/categories/jia-gou/atom.xml" rel="self"/>
  <link href="http://wangchaoqun.com/"/>
  <updated>2014-03-11T10:18:17+08:00</updated>
  <id>http://wangchaoqun.com/</id>
  <author>
    <name><![CDATA[wang chaoqun]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[转]大型高性能网站的十项规则]]></title>
    <link href="http://wangchaoqun.com/blog/2010/04/zhuan-da-xing-gao-xing-neng-wang-zhan-de-shi-xiang-gui-ze.html/"/>
    <updated>2010-04-19T09:56:42+08:00</updated>
    <id>http://wangchaoqun.com/blog/2010/04/zhuan-da-xing-gao-xing-neng-wang-zhan-de-shi-xiang-gui-ze</id>
    <content type="html"><![CDATA[<p>[转]<a href="http://www.programmer.com.cn/2854/">作者：Steve Mushero 译者：侯伯薇</a><br/>
在我们公司ChinaNetCloud，见过多种不同类型的网站和系统，有好也有差。其中有些系统拥有良好的服务器/网络架构，并且进行了合理的调整和监控 ；然而一般的系统都会有安全和性能上的问题，不能良好运行，也无法变得更流行。</p>

<p>在中国，开源的LAMP栈是最流行的网络架构，它使用PHP开发，运行在Apache服务器上，以MySQL作为数据库，所有这些都运行在Linux上。它是个可靠的平台，运行良好，是现在全球最流行的Internet系统架构。然而，我们很难对其规模进行正确的扩展并保持安全性，因为每个应用层都有其自身的问题、缺陷和最佳实践。我们的工作就是帮助企业用最低的操作成本来创建并运行高性能的、可伸缩的、安全的系统，因此对于这类问题我们有很丰富的经验。<!--more--></p>

<p>当前的实际情况是，很多网站都是由开发人员快速而廉价地创建，通常没有任何IT人员或者经理，只是由程序员来管理系统。造成的结果是，虽然花费很低的成本网站就可以开始运行，但是当拥有大量用户、需要扩展规模的时候，通常就会面临真正的问题。毕竟，中国拥有三亿八千万的Internet用户，如果其中的0.01%访问这个站点，就很容易引发25万~50万的页面访问量。这些问题在各个级别上都会产生，下面总结的规则是对最一般的问题进行概述，并且说明为什么这些规则如此重要，以及最好采用什么方法来修正它们。遵循这些建议的站点会提高它的可伸缩性、安全性以及操作上的稳定性。</p>

<p><img style="text-align:center;" title="大型网站的十项规则" src="http://www.programmer.com.cn/wp-content/uploads/2010/04/大型网站的十项规则.gif"></p>

<h2>1. 使用合适的会话管理  </h2>

<p>第一个想到的扩展系统的方法就是添加更多硬件。例如，使用两台服务器而不是一台。这听着合理，但会产生潜在问题：会话管理。这对Java程序来说是很严重的问题，在PHP中也会产生可延展性问题，对于数据库的负载尤其如此。</p>

<p>会话被定义为单独的最终用户登录或者连接一段时间，其中通常会包含多个TCP/IP的HTTP连接、几个Web页面，通常还包括几十个甚至上百个页面元素，如框架、菜单、Ajax更新等。所有这些HTTP请求都需要知道用户是谁，才能满足安全的要求，并向用户传送适当的内容，因为这些都是会话的组成部分。通常每个会话都会包括相互关联的会话数据，如用户名、用户ID、历史、购物车、统计资料等等信息。</p>

<p>问题在于，在有两台Web服务器和多个HTTP连接的情况下，用户流量会在两台服务器之间分配和移动，服务器很难知道用户是谁，并对所有数据进行跟踪，因为每个页面或者页面的组成部分都可能来自不同的服务器。在PHP中，通常是这样解决的，在第一次连接或登录的时候就创建一个会话ID并将其放在Cookie中，然后这个Cookie会和每个HTTP请求一起发送。</p>

<p>这样做带来一个问题，接下来每段PHP脚本都需要基于ID来查找会话数据。由于PHP无法在执行过程之间保持状态（这与Java不同），这个会话数据需要存储在某个地方，通常是在数据库中。但是，如果复杂的页面需要在每个页面载入过程中对其进行十次查找（这是经常要做的），那就意味着每个页面都要执行10次SQL查询，这会导致数据库上很大的负载。</p>

<p>在前面所举的中国Internet用户0.01%的例子中，可能很容易在每秒内仅仅为了管理会话就生成上百个查询。解决方法是一直使用位于Cookie中的会话ID，并且使用像Memcached之类的服务来缓存会话数据以获得高性能。</p>

<p>还要注意其中存在安全性的问题，因为黑客可以伪造另一个用户的会话ID，这是很容易找到或看到的，特别是在公用的Wi-Fi中。解决方法是对会话ID进行恰当的加密或者签名，并将其与时间区间、IP地址以及其他关键信息 像浏览器或者其他细节相绑定。在Internet上有很多不错的关于良好的会话管理的例子，你可以根据需要找到最适合的。</p>

<h2>2. 总是要考虑安全性</h2>

<p>尽管编写像防止SQL注入和登录安全之类的代码涉及很多安全问题，但不幸的是，几乎没有人考虑过安全性，而那些考虑到的人也没有对其进行很好地理解。而本文要关注的是操作性的系统安全。对于这类安全，我们的焦点集中在三个安全领域：防火墙、运行的用户以及文件访问权限。</p>

<p>除了配置专门的硬件防火墙（像Cisco的ASA）之外，所有服务器都还应该运行像Iptables之类的防火墙，它会保护服务器免受其他威胁和攻击。这些威胁和攻击可能来自公共的Internet、其他服务器或本地服务器，也包括使用VPN或者SSH通道的开发和操作人员。我们仅对指定的IP开放确实需要的端口。Iptables可能会很复杂，但是有很多不错的模板，我们通常可以使用它们来帮助客户创建Iptables。例如，默认的RedHat或者CentOS防火墙的配置说明只有10行，显然并不实用。我们最佳实践的Iptables配置大概有5页，这其中包含了Linux所能提供的最高级的安全防范。</p>

<p>所有公用的服务，都应该运行在专门的用户下，如Apache。切记永远都不要使用Root用户运行，因为这会让任何闯入到Apache的用户接管整个服务器。如果Apache只是运行在Apache用户下或者运行在Nobody下，那么闯入Apache就不是一件容易的事情了。</p>

<p>Web服务器运行或者服务的文件（像.php和.html文件）对于Web服务器的用户应该是不可写的。这意味着Apache或者Nginx用户不应该拥有Web目录的写权限。有很多方法都可以做到这一点，而最简单的就是将这些文件为其他用户所有，然后让Apache/Nginx等用户归属于能够使用640权限读取文件的组中。这会防范几乎所有的黑客和针对页面的攻击。</p>

<p>此外，永远不要使用Ftp来上传文件，特别是在公用的Wi-Fi环境中，因为在其中黑客很容易盗取用户名和密码。取而代之的是使用Sftp会更加安全。另外，每个雇员都应该拥有自己的用户ID和随机密码。</p>

<h2>3. 使用标准的路径和安装配置</h2>

<p>一个令人讨厌的部署问题是，开发者很少考虑他们的软件会被部署到生产Web服务器的什么位置，以及如何部署。我们看到过许多大型的系统将它们的PHP代码部署在/home/xiaofeng或者/web/code路径下。事实上，这两个路径都是非常不标准的，并且会带来操作和安全性的问题。当这些系统从开发环境转移到测试环境再到生产环境中时，因为每个安装配置都是非标准的，所以经常会出现问题，这时就需要开发者调整才能够正常工作。</p>

<p>你应该总是使用标准的安装包和二进制文件来安装像Apache之类的服务器。不要从源代码编译或者安装Tarball，因为这会导致长期稳定性和管理上的问题，另外在服务器上安装多个不同的版本也会造成混淆。</p>

<p>Web 站点应该总是在指定的平台和Linux发布的标准路径下进行测试和部署 ，像 RedHat 或者CentOS下的/var/www/html路径。这有助于对系统进行有效的权限管理、备份、配置、监控以及其他操作。</p>

<p>Web服务器的日志应该存放在/var/logs或者/var/logs/app_name下，而不应该位于主代码区域。这样做的原因不仅仅是因为这些标准的路径很重要，更应该关注的是，恰当地配置服务器会将/var配置为分离的文件系统。如果应用程序突然写入了大量日志并占用所有磁盘空间，由于我们做了以上的配置就不会导致系统崩溃，或者其他严重的问题。如果日志位于其他位置，就可能会产生问题。</p>

<h2>4. 总是使用日志</h2>

<p>在Web系统中做多少日志都不为过。所有系统都应该将重要的数据写入到日志中，不管是它们自己的日志还是系统的Syslog。Cron的Job以及其他Shell脚本或者C语言的程序，对日志都有相应标准以及简单的函数。在Shell脚本中，只需要使用 Logger命令就可以实现日志的写入。在脚本启动/停止、重要的脚本执行以及实时数据产生的情况下都要执行写入日志操作。这样出现问题的时候，查看主要的系统日志就可以很容易地看到发生了什么。</p>

<p>大型系统经常会使用专门的工具如Local5来记录日志，并配置Syslog或者Syslog-ng来将其存放在单独的文件中，这样会更容易使用。需要注意的是，Syslog工具和Logger（以及任何Syslog调用）默认优先使用user.notice，如有必要，你可以对其进行调整。</p>

<p>一个好的系统会对程序进行配置，用来打开或者关闭日志，并可以选择在每模块或者功能的级别上应用不同级别的日志。这使得我们可以记录非常详细和强大的日志，用来分析和调试在生产操作中所发生的问题。</p>

<h2>5. 使用良好的数据库设计和SQL</h2>

<p>在任何系统中，数据库通常是最大的性能瓶颈。而影响数据库性能的最大两个问题是数据库设计和SQL代码质量。很多系统都拥有良好的或者至少是可用的数据库设计，但由于没有经过适当的性能测试，SQL代码质量通常都会很差。这样的SQL代码在开发环境中可能运行很快，因为其中只有小数据集和最小的负载。但是当成千上万的用户同时读取数据库中上百万条记录的时候，它就很可能会崩溃。</p>

<p>不幸的是，这些问题一开始并不明显，直到系统增大、突然开始崩溃的时候才会显现出来。在增大的过程中，数据库系统看起来运行得很快（因为数据都位于内存中，而且很少有并发的查询），并且对用户的响应也很快，但实际上它的内部运行效率很低。这并不重要，我们关注的是在系统增大并遇到性能问题之前找到这些问题并加以解决。</p>

<p>关于这个问题有很多不错的书和站点进行了解析，其中的关键工具包括慢查询日志、INNODB状态系统，以及描述当前性能的MySQL统计信息。我们见到过很多系统每秒会读取500,000条数据，这是出现SQL问题的明显预兆，但公司往往对其一无所知直到服务器开始崩溃。</p>

<p>MySQL系统应该对所有数据使用INNODB存储引擎，因为INNODB与之前的MyISAM相比，运行得更快、更稳定，并且管理性能和备份工作也更加容易和快捷。在主配置文件中，INNODB应该被设置为默认的数据库引擎，并且系统应该不时地进行检查，看是否意外创建了MyISAM的表。</p>

<h2>6. 总要拥有良好的DB配置和备份</h2>

<p>很多公司都没有良好的备份机制，也不知道如何恰当地完成这项工作。MySQL的Dump是不够的，因为最好的备份方法是使用LVM快照和INNODB对系统进行热备份，从而得到超快的速度和超高的可靠性。</p>

<p>另外，在将所有备份文件从服务器上转移出来之前要进行压缩和加密。另外还要确保拥有设计合理的MySQL配置。MySQL默认安装使用说明中只有5~10行关于配置的说明，这根本不适合开发使用。而我们提供给客户的最佳实践文档足足有10页那么长。文档中大约有100种有用的关于安全、性能和稳定性问题的设定，包括防止数据败坏，其中很多设定都是非常重要的。</p>

<h2>7. 使用读/写数据库分离</h2>

<p>随着系统变得越来越庞大，特别是当它们拥有很差的SQL时，一台数据库服务器通常不足以处理负载。但是多个数据库意味着重复，除非你对数据进行了分离。更一般地，这意味着建立主/从副本系统，其中程序会对主库编写所有的Update、Insert和Delete变更语句，而所有Select的数据都读取自从数据库（或者多个从数据库）。</p>

<p>尽管概念上很简单，但是想要合理、精确地实现并不容易，这可能需要大量的代码工作。因此，即便在开始时使用同一台数据库服务器，也要尽早计划在PHP中使用分离的DB连接来进行读写操作。如果正确地完成该项工作，那么系统就可以扩展到2台、3台甚至12台服务器，并具备高可用性和稳定性。</p>

<h2>8. 使用类似Memcached之类的数据库缓存</h2>

<p>即便有了好的数据库设计、SQL和读写分离，大型的系统仍然需要更快的性能，特别是对会话状态、好友列表以及BBS文字之类的东西。为了达到这个目的，我们可以使用像MemCached之类的数据缓存，它是一个高性能的简单数据缓存，已经被所有最大型的站点使用。但是要小心的是，不要100%依赖于一台Memcache服务器来提高性能，因为如果那台服务器崩溃了，就会破坏整个系统的性能。在这种情况下，应该使用2~3台Memcache服务器形成簇集架构，并且有选择地包含一个缓存准备过程，如果缓存服务器重启，需要重新载入数据，它能够快速地载入缓存。</p>

<h2>9. 构建测试和开发环境</h2>

<p>很多公司只有开发者的桌面系统和他们的生产服务器。当系统变得越来越大、越来越复杂时，测试和管理代码就会导致严重的问题。最佳的实践是拥有两个测试系统，一个用于开发者的代码和功能的整合测试，另一个要与生产环境完全一致，从而更容易向生产环境平滑地过渡。幸运的是，现在使用云计算（或者私有云）可以轻松达到这一点。一个5~10台服务器的生产环境，可以很容易地在办公室或者IDC中使用一台服务器来复制，从而用于测试，而这台服务器我们可以用于多个客户的项目。</p>

<h2>10. 使用版本控制</h2>

<p>最后，要对一切使用版本控制，包括测试和生产环境的部署。很多开发者都使用SVN或者类似的方法。在理想状态下，这些方法可以被用于所有代码、脚本、HTML、图片、配置、文档和测试。版本控制应该是代码转移到测试环境的必经之路，而不是简单地复制或者使用tar文件，因为这二者都是不可靠的。开发者应该将所有一切都签入，打上标签，然后将它们签出到测试系统。如果所有都没问题，那么它们会将该版本签出到生产环境。</p>

<h2>总结</h2>

<p>不管是在开发还是在运营过程中，创建可靠的高性能Web系统都有很多应该注意的事项。本文试图从可操作性和可靠性的角度讨论最重要的几点。当你构建和管理站点的时候，请不要忘了这些重要的问题。遵循这些规则会有助于确保系统长久、良好地运行。</p>

<p>作者简介：
Steve Mushero，ChinaNetCloud公司联合创始人、CEO兼CTO，拥有全球20多年的技术管理经验。曾担任土豆网、Intermind和Advanced Management Systems等多家企业CTO<br/>
译者简介：<br/>
侯伯薇，生于凤城，学在春城，做过国内和对日项目，现在大连某保险公司工作。乐于钻研技术，同时注重业务知识，勤于思考，愿意与人交流和分享。<br/>
（本文来自《程序员》杂志2010年4月刊）</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[转]大型网站架构演变和知识体系]]></title>
    <link href="http://wangchaoqun.com/blog/2008/09/zhuan-da-xing-wang-zhan-jia-gou-yan-bian-he-zhi-shi-ti-xi.html/"/>
    <updated>2008-09-06T14:57:20+08:00</updated>
    <id>http://wangchaoqun.com/blog/2008/09/zhuan-da-xing-wang-zhan-jia-gou-yan-bian-he-zhi-shi-ti-xi</id>
    <content type="html"><![CDATA[<p><a href="http://www.blogjava.net/BlueDavy/archive/2008/09/03/226749.html">转自BlueDavy之技术Blog</a> 之前也有一些介绍大型网站架构演变的文章，例如LiveJournal的、ebay的，都是非常值得参考的，不过感觉他们讲的更多的是每次演变的结果，而没有很详细的讲为什么需要做这样的演变，再加上近来感觉有不少同学都很难明白为什么一个网站需要那么复杂的技术，于是有了写这篇文章的想法，在这篇文章中 将阐述一个普通的网站发展成大型网站过程中的一种较为典型的架构演变历程和所需掌握的知识体系，希望能给想从事互联网行业的同学一点初步的概念，:)，文中的不对之处也请各位多给点建议，让本文真正起到抛砖引玉的效果。<!--more--></p>

<h2>架构演变第一步：物理分离webserver和数据库</h2>

<p>最开始，由于某些想法，于是在互联网上搭建了一个网站，这个时候甚至有可能主机都是租借的，但由于这篇文章我们只关注架构的演变历程，因此就假设这个时候 已经是托管了一台主机，并且有一定的带宽了，这个时候由于网站具备了一定的特色，吸引了部分人访问，逐渐你发现系统的压力越来越高，响应速度越来越慢，而这个时候比较明显的是数据库和应用互相影响，应用出问题了，数据库也很容易出现问题，而数据库出问题的时候，应用也容易出问题，于是进入了第一步演变阶段：将应用和数据库从物理上分离，变成了两台机器，这个时候技术上没有什么新的要求，但你发现确实起到效果了，系统又恢复到以前的响应速度了，并且支撑住了更高的流量，并且不会因为数据库和应用形成互相的影响。</p>

<p>看看这一步完成后系统的图示：</p>

<p><img src="http://www.blogjava.net/images/blogjava_net/bluedavy/arch/1.PNG"></p>

<p>这一步涉及到了这些知识体系：</p>

<p>这一步架构演变对技术上的知识体系基本没有要求。</p>

<h2>架构演变第二步：增加页面缓存</h2>

<p>好景不长，随着访问的人越来越多，你发现响应速度又开始变慢了，查找原因，发现是访问数据库的操作太多，导致数据连接竞争激烈，所以响应变慢，但数据库连 接又不能开太多，否则数据库机器压力会很高，因此考虑采用缓存机制来减少数据库连接资源的竞争和对数据库读的压力，这个时候首先也许会选择采用squid 等类似的机制来将系统中相对静态的页面（例如一两天才会有更新的页面）进行缓存（当然，也可以采用将页面静态化的方案），这样程序上可以不做修改，就能够 很好的减少对webserver的压力以及减少数据库连接资源的竞争，OK，于是开始采用squid来做相对静态的页面的缓存。</p>

<p>看看这一步完成后系统的图示：</p>

<p><img src="http://www.blogjava.net/images/blogjava_net/bluedavy/arch/2.PNG"></p>

<p>这一步涉及到了这些知识体系：</p>

<p>前端页面缓存技术，例如squid，如想用好的话还得深入掌握下squid的实现方式以及缓存的失效算法等。</p>

<h2>架构演变第三步：增加页面片段缓存</h2>

<p>增加了squid做缓存后，整体系统的速度确实是提升了，webserver的压力也开始下降了，但随着访问量的增加，发现系统又开始变的有些慢了，在尝 到了squid之类的动态缓存带来的好处后，开始想能不能让现在那些动态页面里相对静态的部分也缓存起来呢，因此考虑采用类似ESI之类的页面片段缓存策略，OK，于是开始采用ESI来做动态页面中相对静态的片段部分的缓存。</p>

<p>看看这一步完成后系统的图示：</p>

<p><img src="http://www.blogjava.net/images/blogjava_net/bluedavy/arch/3.PNG"></p>

<p>这一步涉及到了这些知识体系：</p>

<p>页面片段缓存技术，例如ESI等，想用好的话同样需要掌握ESI的实现方式等；</p>

<h2>架构演变第四步：数据缓存</h2>

<p>在采用ESI之类的技术再次提高了系统的缓存效果后，系统的压力确实进一步降低了，但同样，随着访问量的增加，系统还是开始变慢，经过查找，可能会发现系 统中存在一些重复获取数据信息的地方，像获取用户信息等，这个时候开始考虑是不是可以将这些数据信息也缓存起来呢，于是将这些数据缓存到本地内存，改变完毕后，完全符合预期，系统的响应速度又恢复了，数据库的压力也再度降低了不少。</p>

<p>看看这一步完成后系统的图示：</p>

<p><img src="http://www.blogjava.net/images/blogjava_net/bluedavy/arch/4.PNG"></p>

<p>这一步涉及到了这些知识体系：</p>

<p>缓存技术，包括像Map数据结构、缓存算法、所选用的框架本身的实现机制等。</p>

<h2>架构演变第五步： 增加webserver</h2>

<p>好景不长，发现随着系统访问量的再度增加，webserver机器的压力在高峰期会上升到比较高，这个时候开始考虑增加一台webserver，这也是为了同时解决可用性的问题，避免单台的webserver down机的话就没法使用了，在做了这些考虑后，决定增加一台webserver，增加一台webserver时，会碰到一些问题，典型的有：
1、如何让访问分配到这两台机器上，这个时候通常会考虑的方案是Apache自带的负载均衡方案，或LVS这类的软件负载均衡方案；
2、如何保持状态信息的同步，例如用户session等，这个时候会考虑的方案有写入数据库、写入存储、cookie或同步session信息等机制等；
3、如何保持数据缓存信息的同步，例如之前缓存的用户数据等，这个时候通常会考虑的机制有缓存同步或分布式缓存；
4、如何让上传文件这些类似的功能继续正常，这个时候通常会考虑的机制是使用共享文件系统或存储等；
在解决了这些问题后，终于是把webserver增加为了两台，系统终于是又恢复到了以往的速度。</p>

<p>看看这一步完成后系统的图示：</p>

<p><img src="http://www.blogjava.net/images/blogjava_net/bluedavy/arch/5.PNG"></p>

<p>这一步涉及到了这些知识体系：</p>

<p>负载均衡技术（包括但不限于硬件负载均衡、软件负载均衡、负载算法、linux转发协议、所选用的技术的实现细节等）、主备技术（包括但不限于ARP欺骗、linux heart-beat等）、状态信息或缓存同步技术（包括但不限于Cookie技术、UDP协议、状态信息广播、所选用的缓存同步技术的实现细节等）、共享文件技术（包括但不限于NFS等）、存储技术（包括但不限于存储设备等）。</p>

<h2>架构演变第六步：分库</h2>

<p>享受了一段时间的系统访问量高速增长的幸福后，发现系统又开始变慢了，这次又是什么状况呢，经过查找，发现数据库写入、更新的这些操作的部分数据库连接的 资源竞争非常激烈，导致了系统变慢，这下怎么办呢，此时可选的方案有数据库集群和分库策略，集群方面像有些数据库支持的并不是很好，因此分库会成为比较普遍的策略，分库也就意味着要对原有程序进行修改，一通修改实现分库后，不错，目标达到了，系统恢复甚至速度比以前还快了。</p>

<p>看看这一步完成后系统的图示：</p>

<p><img src="http://www.blogjava.net/images/blogjava_net/bluedavy/arch/6.PNG"></p>

<p>这一步涉及到了这些知识体系：</p>

<p>这一步更多的是需要从业务上做合理的划分，以实现分库，具体技术细节上没有其他的要求；</p>

<p>但同时随着数据量的增大和分库的进行，在数据库的设计、调优以及维护上需要做的更好，因此对这些方面的技术还是提出了很高的要求的。</p>

<h2>架构演变第七步：分表、DAL和分布式缓存</h2>

<p>随着系统的不断运行，数据量开始大幅度增长，这个时候发现分库后查询仍然会有些慢，于是按照分库的思想开始做分表的工作，当然，这不可避免的会需要对程序 进行一些修改，也许在这个时候就会发现应用自己要关心分库分表的规则等，还是有些复杂的，于是萌生能否增加一个通用的框架来实现分库分表的数据访问，这个在ebay的架构中对应的就是DAL，这个演变的过程相对而言需要花费较长的时间，当然，也有可能这个通用的框架会等到分表做完后才开始做，同时，在这个阶段可 能会发现之前的缓存同步方案出现问题，因为数据量太大，导致现在不太可能将缓存存在本地，然后同步的方式，需要采用分布式缓存方案了，于是，又是一通考察和折磨，终于是将大量的数据缓存转移到分布式缓存上了。</p>

<p>看看这一步完成后系统的图示：</p>

<p><img src="http://www.blogjava.net/images/blogjava_net/bluedavy/arch/7.PNG"></p>

<p>这一步涉及到了这些知识体系：</p>

<p>分表更多的同样是业务上的划分，技术上涉及到的会有动态hash算法、consistent hash算法等；</p>

<p>DAL涉及到比较多的复杂技术，例如数据库连接的管理（超时、异常）、数据库操作的控制（超时、异常）、分库分表规则的封装等；</p>

<h2>架构演变第八步：增加更多的webserver</h2>

<p>在做完分库分表这些工作后，数据库上的压力已经降到比较低了，又开始过着每天看着访问量暴增的幸福生活了，突然有一天，发现系统的访问又开始有变慢的趋势 了，这个时候首先查看数据库，压力一切正常，之后查看webserver，发现apache阻塞了很多的请求，而应用服务器对每个请求也是比较快的，看来 是请求数太高导致需要排队等待，响应速度变慢，这还好办，一般来说，这个时候也会有些钱了，于是添加一些webserver服务器，在这个添加 webserver服务器的过程，有可能会出现几种挑战：
1、Apache的软负载或LVS软负载等无法承担巨大的web访问量（请求连接数、网络流量等）的调度了，这个时候如果经费允许的话，会采取的方案是购 买硬件负载，例如F5、Netsclar、Athelon之类的，如经费不允许的话，会采取的方案是将应用从逻辑上做一定的分类，然后分散到不同的软负载集群中；
2、原有的一些状态信息同步、文件共享等方案可能会出现瓶颈，需要进行改进，也许这个时候会根据情况编写符合网站业务需求的分布式文件系统等；
在做完这些工作后，开始进入一个看似完美的无限伸缩的时代，当网站流量增加时，应对的解决方案就是不断的添加webserver。</p>

<p>看看这一步完成后系统的图示：</p>

<p><img src="http://www.blogjava.net/images/blogjava_net/bluedavy/arch/8.PNG"></p>

<p>这一步涉及到了这些知识体系：</p>

<p>到了这一步，随着机器数的不断增长、数据量的不断增长和对系统可用性的要求越来越高，这个时候要求对所采用的技术都要有更为深入的理解，并需要根据网站的需求来做更加定制性质的产品。</p>

<h2>架构演变第九步：数据读写分离和廉价存储方案</h2>

<p>突然有一天，发现这个完美的时代也要结束了，数据库的噩梦又一次出现在眼前了，由于添加的webserver太多了，导致数据库连接的资源还是不够用，而这个时候又已经分库分表了，开始分析数据库的压力状况，可能会发现数据库的读写比很高，这个时候通常会想到数据读写分离的方案，当然，这个方案要实现并不 容易，另外，可能会发现一些数据存储在数据库上有些浪费，或者说过于占用数据库资源，因此在这个阶段可能会形成的架构演变是实现数据读写分离，同时编写一些更为廉价的存储方案，例如BigTable这种。</p>

<p>看看这一步完成后系统的图示：</p>

<p><img src="http://www.blogjava.net/images/blogjava_net/bluedavy/arch/9.PNG"></p>

<p>这一步涉及到了这些知识体系：</p>

<p>数据读写分离要求对数据库的复制、standby等策略有深入的掌握和理解，同时会要求具备自行实现的技术；</p>

<p>廉价存储方案要求对OS的文件存储有深入的掌握和理解，同时要求对采用的语言在文件这块的实现有深入的掌握。</p>

<h2>架构演变第十步：进入大型分布式应用时代和廉价服务器群梦想时代</h2>

<p>经过上面这个漫长而痛苦的过程，终于是再度迎来了完美的时代，不断的增加webserver就可以支撑越来越高的访问量了，对于大型网站而言，人气的重要毋 庸置疑，随着人气的越来越高，各种各样的功能需求也开始爆发性的增长，这个时候突然发现，原来部署在webserver上的那个web应用已经非常庞大 了，当多个团队都开始对其进行改动时，可真是相当的不方便，复用性也相当糟糕，基本是每个团队都做了或多或少重复的事情，而且部署和维护也是相当的麻烦， 因为庞大的应用包在N台机器上复制、启动都需要耗费不少的时间，出问题的时候也不是很好查，另外一个更糟糕的状况是很有可能会出现某个应用上的bug就导 致了全站都不可用，还有其他的像调优不好操作（因为机器上部署的应用什么都要做，根本就无法进行针对性的调优）等因素，根据这样的分析，开始痛下决心，将 系统根据职责进行拆分，于是一个大型的分布式应用就诞生了，通常，这个步骤需要耗费相当长的时间，因为会碰到很多的挑战：
1、拆成分布式后需要提供一个高性能、稳定的通信框架，并且需要支持多种不同的通信和远程调用方式；
2、将一个庞大的应用拆分需要耗费很长的时间，需要进行业务的整理和系统依赖关系的控制等；
3、如何运维（依赖管理、运行状况管理、错误追踪、调优、监控和报警等）好这个庞大的分布式应用。
经过这一步，差不多系统的架构进入相对稳定的阶段，同时也能开始采用大量的廉价机器来支撑着巨大的访问量和数据量，结合这套架构以及这么多次演变过程吸取的经验来采用其他各种各样的方法来支撑着越来越高的访问量。</p>

<p>看看这一步完成后系统的图示：</p>

<p><img src="http://www.blogjava.net/images/blogjava_net/bluedavy/arch/10.PNG"></p>

<p>这一步涉及到了这些知识体系：</p>

<p>这一步涉及的知识体系非常的多，要求对通信、远程调用、消息机制等有深入的理解和掌握，要求的都是从理论、硬件级、操作系统级以及所采用的语言的实现都有清楚的理解。</p>

<p>运维这块涉及的知识体系也非常的多，多数情况下需要掌握分布式并行计算、报表、监控技术以及规则策略等等。</p>

<p>说起来确实不怎么费力，整个网站架构的经典演变过程都和上面比较的类似，当然，每步采取的方案，演变的步骤有可能有不同，另外，由于网站的业务不同，会有不同的专业技术的需求，这篇blog更多的是从架构的角度来讲解演变的过程，当然，其中还有很多的技术也未在此提及，像数据库集群、数据挖掘、搜索等，但在真实的演变过程中还会借助像提升硬件配置、网络环境、改造操作系统、CDN镜像等来支撑更大的流量，因此在真实的发展过程中还会有很多的不同，另外一个大型网站要做到的远远不仅仅上面这些，还有像安全、运维、运营、服务、存储等，要做好一个大型的网站真的很不容易，写这篇文章更多的是希望能够引出更多大型网站架构演变的介绍，:)。</p>

<p>ps:最后附上几篇LiveJournal架构演变的文章：
从LiveJournal后台发展看大规模网站性能优化方法
<a href="http://blog.zhangjianfeng.com/article/743">http://blog.zhangjianfeng.com/article/743</a>  <br/>
另外从这里：<a href="http://www.danga.com/words/%E5%A4%A7%E5%AE%B6%E5%8F%AF%E4%BB%A5%E6%89%BE%E5%88%B0%E6%9B%B4%E5%A4%9A%E5%85%B3%E4%BA%8E%E7%8E%B0%E5%9C%A8LiveJournal%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84%E7%9A%84%E4%BB%8B%E7%BB%8D%E3%80%82">http://www.danga.com/words/%E5%A4%A7%E5%AE%B6%E5%8F%AF%E4%BB%A5%E6%89%BE%E5%88%B0%E6%9B%B4%E5%A4%9A%E5%85%B3%E4%BA%8E%E7%8E%B0%E5%9C%A8LiveJournal%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84%E7%9A%84%E4%BB%8B%E7%BB%8D%E3%80%82</a></p>
]]></content>
  </entry>
  
</feed>

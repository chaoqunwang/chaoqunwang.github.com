<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: Ehcache | 超群的博客]]></title>
  <link href="http://wangchaoqun.com/tags/ehcache/atom.xml" rel="self"/>
  <link href="http://wangchaoqun.com/"/>
  <updated>2014-04-16T17:05:27+08:00</updated>
  <id>http://wangchaoqun.com/</id>
  <author>
    <name><![CDATA[wang chaoqun]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Spring Cache之Ehcache和Memcached]]></title>
    <link href="http://wangchaoqun.com/blog/2014/04/spring-cache-zhi-ehcache-he-memcached.html/"/>
    <updated>2014-04-15T14:52:05+08:00</updated>
    <id>http://wangchaoqun.com/blog/2014/04/spring-cache-zhi-ehcache-he-memcached</id>
    <content type="html"><![CDATA[<p>spring框架从3.1版本开始提供了缓存支持：在spring-context.jar里的org.springframework.cache包，以及spring-context-support.jar里的org.springframework.cache包；而且提供了基于ConcurrentHashMap、JCacheCache、EhCache、GuavaCache的实现。<br/>
这里我们先看下基于EhCache的使用，然后考虑集成Memcached；版本：spring3.2和spring4，EhCache2.7，spyMemcached2.8；<br/>
内容还涉及HashMap、LinkedHashMap、synchronizedMap、ConcurrentHashMap、ReentrantLock……  <br/>
<a href="http://docs.spring.io/spring/docs/4.0.x/spring-framework-reference/html/cache.html">参考资料：spring framework 4.0.x reference</a><!--more--></p>

<h2>一、EhCache配置  </h2>

<h3>1. 添加相关jar，添加ehcache.xml</h3>

<p>```xml<br/>
&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;UTF-8&rdquo;?>
&lt;ehcache xmlns:xsi=&ldquo;<a href="http://www.w3.org/2001/XMLSchema-instance">http://www.w3.org/2001/XMLSchema-instance</a>&rdquo;</p>

<pre><code>xsi:noNamespaceSchemaLocation="ehcache.xsd" updateCheck="true"
monitoring="autodetect" dynamicConfig="true"&gt;
&lt;diskStore path="java.io.tmpdir" /&gt;
&lt;defaultCache maxElementsInMemory="10000" maxElementsOnDisk="100000"
    eternal="false" timeToIdleSeconds="120" timeToLiveSeconds="120" overflowToDisk="true" 
    diskPersistent="false" diskExpiryThreadIntervalSeconds="120" memoryStoreEvictionPolicy="LRU" /&gt;
&lt;cache name="notice_cache" maxElementsInMemory="10000" maxElementsOnDisk="100000"
    eternal="true" overflowToDisk="true" diskSpoolBufferSizeMB="50" /&gt;
</code></pre>

<p></ehcache>
```
属性意义基本明确，这里我配置了一个名称是notice_cache的cache节点，其他的可以按此添加。</p>

<h3>2. spring-cache.xml</h3>

<p>配置cacheManager和cacheManagerFactory，并将ehcache.xml配入即可</p>

<p>```xml<br/>
&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;UTF-8&rdquo;?>
&lt;beans xmlns=&ldquo;<a href="http://www.springframework.org/schema/beans">http://www.springframework.org/schema/beans</a>&rdquo;</p>

<pre><code>xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:cache="http://www.springframework.org/schema/cache"
xmlns:p="http://www.springframework.org/schema/p"
xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd
    http://www.springframework.org/schema/cache http://www.springframework.org/schema/cache/spring-cache-3.2.xsd"&gt;

&lt;cache:annotation-driven cache-manager="cacheManager" /&gt;

&lt;bean id="cacheManager" class="org.springframework.cache.ehcache.EhCacheCacheManager"
    p:cacheManager-ref="cacheManagerFactory" /&gt;

&lt;bean id="cacheManagerFactory" class="org.springframework.cache.ehcache.EhCacheManagerFactoryBean"
    p:configLocation="classpath:ehcache.xml" p:shared="false" /&gt;
</code></pre>

<p></beans>
```</p>

<h3>3. @Cacheable\@CacheEvict\@CachePut\@Caching&hellip;</h3>

<p>注解加在相应方法上，支持spel，详细参见文档<a href="http://docs.spring.io/spring/docs/4.0.x/spring-framework-reference/html/cache.html">查阅spring 4.0.x reference</a></p>

<p>```java</p>

<pre><code>@Cacheable(value = "notice_cache", key = "'notice'+#id")
public Notice get(String id) {
    return noticeDao.get(id);
}

@Cacheable(value = "notice_cache")
public List&lt;Notice&gt; search(String keywords, Date fromTime, Date toTime, Integer[] status, Page page) {
    //...
}
</code></pre>

<p><code>
至此配置完了，run一下，报错：没有序列化，将vo实现Serializable接口  
</code>java<br/>
public class Notice implements Serializable {
```</p>

<p>标签：<a href="/blog/categories/spring">spring</a></p>

<p>这样ehcache集成完了，get方法对同一条记录只从数据库查询一次，cache是成功的，但search方法却一直读库，这里没有设置cache的key，设置的话如果是固定的，那么每次结果集都一样，不会更新；文档说不设key，将使用默认key生成器DefaultKeyGenerator：<br/>
```java<br/>
public class DefaultKeyGenerator implements KeyGenerator {</p>

<pre><code>public static final int NO_PARAM_KEY = 0;
public static final int NULL_PARAM_KEY = 53;

public Object generate(Object target, Method method, Object... params) {
    if (params.length == 1) {
        return (params[0] == null ? NULL_PARAM_KEY : params[0]);
    }
    if (params.length == 0) {
        return NO_PARAM_KEY;
    }
    int hashCode = 17;
    for (Object object : params) {
        hashCode = 31 * hashCode + (object == null ? NULL_PARAM_KEY : object.hashCode());
    }
    return Integer.valueOf(hashCode);
}
</code></pre>

<p>}
```
<strong><em>问题</em></strong>就在于object.hashCode()，看方法的参数string没问题，date没问题，Integer数组使用的就是Object类的hashCode是个内存地址，每次执行都变，要改用Arrays.hashCode(array)才不会变；<br/>
当然，分页类page也要重写hashCode；顺便说下，apache的commons-lang.jar提供了EqualsBuilder、HashCodeBuilder、ToStringBuilder可用于重写各方法。</p>

<h4>4. 自定义key生成器</h4>

<p>解决上面问题：重写生成器（继承DefaultKeyGenerator，需要注意的是对于param是list,set,map取hashcode，其泛型类也要重写hashCode方法）并配置:<br/>
```</p>

<pre><code>&lt;cache:annotation-driven cache-manager="cacheManager" key-generator="keyGenerator"/&gt;
&lt;bean id="keyGenerator" class="......CustomKeyGenerator" /&gt;
</code></pre>

<p><code>
</code>java<br/>
public class CustomKeyGenerator extends DefaultKeyGenerator {</p>

<pre><code>public Object generate(Object target, Method method, Object... params) {
    StringBuffer buffer = new StringBuffer();
    buffer.append(target.getClass().getName());
    buffer.append(".");
    buffer.append(method.getName());
    buffer.append(".");
    if (params.length &gt; 0) {
        for (Object each : params) {
            if (each != null) {
                if (each instanceof AtomicInteger || each instanceof AtomicLong || each instanceof BigDecimal
                        || each instanceof BigInteger || each instanceof Byte || each instanceof Double
                        || each instanceof Float || each instanceof Integer || each instanceof Long
                        || each instanceof Short) {
                    buffer.append(each);
                } else if (each instanceof Object[]) {
                    buffer.append(Arrays.hashCode((Object[]) each));
                } else {
                    buffer.append(each.hashCode());
                }
            } else {
                buffer.append(NO_PARAM_KEY);
            }
        }
    } else {
        buffer.append(NO_PARAM_KEY);
    }
    return buffer.toString().hashCode();
}
</code></pre>

<p>}
```</p>

<h4>5. 添加、更新、删除</h4>

<p>显然@Cacheable是缓存，@CacheEvict是擦除，@CachePut相当于擦除后再缓存，对于key是确定的很好，比如getById(id)，update(obj)，其key可以用id，obj.id；update时也可以用@CachePut，要注意update方法要返回更新后的obj，void不行。</p>

<p>问题又出现了：不明确的key如何更新？例如search，当新添加一条记录后，就不能使用@CacheEvict(value=&ldquo;notice_cache&rdquo;, key=&ldquo;?&rdquo;)，因为取不到key，也不能模糊匹配；这种情况下只能使用@CacheEvict(value = &ldquo;notice_cache&rdquo;, allEntries = true)，将notice_cache所有的缓存擦除，多少有点粗糙（在后面使用memcached我实现了一种方法能够精细擦除）</p>

<p>还有一个<strong>注意事项</strong>：因其使用aop的动态代理，对于内部调用无效，例如publish方法没加cache注解，内部调用update方法（加了@CachePut）更新状态值，但cache不会更新；controller调用service方法可以，controller方法也可以加，但如果参数有request，每次都变，所以没用，一般加在service方法上。</p>

<h2>二、集成Memcached  </h2>

<p>背景：现在的项目使用memcached做缓存，基本上是编码式的，在需要的时候，生成key，将value转为json再set到缓存，因此打算使用注解式更优雅的处理，就需要实现spring cache的相关接口和自定义一些方法</p>

<h4>1. spring集成Memcached，使用spyMemcached</h4>

<p>```xml</p>

<pre><code>&lt;bean id="memcachedClient" class="net.spy.memcached.spring.MemcachedClientFactoryBean"&gt;
    &lt;property name="servers" value="${memcached.servers}" /&gt;
    &lt;property name="protocol" value="BINARY" /&gt;
    &lt;property name="transcoder"&gt;
        &lt;bean class="net.spy.memcached.transcoders.SerializingTranscoder"&gt;
            &lt;property name="compressionThreshold" value="${memcached.transcoder.compressionThreshold}" /&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
    &lt;property name="opTimeout" value="${memcached.opTimeout}" /&gt;
    &lt;property name="timeoutExceptionThreshold" value="1998" /&gt;
    &lt;property name="hashAlg"&gt;
            &lt;value type="net.spy.memcached.DefaultHashAlgorithm"&gt;${memcached.hashAlg}&lt;/value&gt;
    &lt;/property&gt;
    &lt;property name="locatorType" value="${memcached.locatorType}" /&gt;
    &lt;property name="failureMode" value="${memcached.failureMode}" /&gt;
    &lt;property name="useNagleAlgorithm" value="${memcached.useNagleAlgorithm}" /&gt;
&lt;/bean&gt;
</code></pre>

<p><code>
properties:
</code></p>

<h4>memcached config</h4>

<p>memcached.servers=ip:port
memcached.protocol=BINARY
memcached.transcoder.compressionThreshold=1024
memcached.opTimeout=1000
memcached.timeoutExceptionThreshold=1998
memcached.hashAlg=KETAMA_HASH
memcached.locatorType=CONSISTENT
memcached.failureMode=Redistribute
memcached.useNagleAlgorithm=false
```</p>

<p>标签：<a href="/blog/categories/tech">技术</a></p>

<h4>2. 实现MemcachedCacheManager和MemcachedCache</h4>

<p>参考ehcache的源码（org.springframework.cache.ehcache包里）：EhCacheCache和EhCacheCacheManager，manager用来获取cache，重写了getCache和loadCaches方法，这样配置在ehcache.xml里的cache name都会实例化成每个EhCacheCache，当执行到@Cacheable的方法上，就会调用getCache(name)获取cache，再根据key取得value；</p>

<p><strong><em>MemcachedCacheManager</em></strong>： <br/>
```java
public class MemcachedCacheManager extends AbstractCacheManager {</p>

<pre><code>// cache集合
private Collection&lt;Cache&gt; caches;
// 注入memcachedClient（后面会有配置）
private MemcachedClient client;

public MemcachedCacheManager() {}

public MemcachedCacheManager(MemcachedClient client) {
    this.client = client;
}

public void setClient(MemcachedClient client) {
    this.client = client;
}

// AbstractCacheManager不允许loadCaches返回空，所以初始化时添加一个默认cache
protected Collection&lt;? extends Cache&gt; loadCaches() {
    if (caches == null) {
        caches = new LinkedHashSet&lt;Cache&gt;();
        caches.add(new MemcachedCache("DEFAULT_CACHE", client));
    }
    return caches;
}

// 根据名称获取cache，对应注解里的value如notice_cache，没有就创建并加入cache管理
public Cache getCache(String name) {
    Cache cache = super.getCache(name);
    if (cache == null) {
        cache = new MemcachedCache(name, client);
        super.addCache(cache);
    }
    return cache;
}
</code></pre>

<p>}
<code>
这样应用启动时实例化manager，在执行加缓存注解的的方法时，会调用getCache(获取或新建cache)，根据缓存的key从cache中取值（没有就读库，然后将结果加入cache，下次相同的key就能取到缓存的值了）  
要写MemcachedCache实现</code>org.springframework.cache.Cache<code>接口，先来分析***EhCacheCache***：
</code>java
public class EhCacheCache implements Cache {</p>

<pre><code>// 使用Ehcache的cache，来做get,put,evict...，集成memcached就要使用memcachedClient
private final Ehcache cache;

/**
 * Create an {@link EhCacheCache} instance.
 * @param ehcache backing Ehcache instance
 */
public EhCacheCache(Ehcache ehcache) {
    Assert.notNull(ehcache, "Ehcache must not be null");
    Status status = ehcache.getStatus();
    Assert.isTrue(Status.STATUS_ALIVE.equals(status),
            "An 'alive' Ehcache is required - current cache is " + status.toString());
    this.cache = ehcache;
}
// 也就是ehcache.xml里配置的
public String getName() {
    return this.cache.getName();
}
// 底层使用的cache，要改用memcachedClient
public Ehcache getNativeCache() {
    return this.cache;
}
// 从cache取值，改用memcachedClient取值
public ValueWrapper get(Object key) {
    Element element = this.cache.get(key);
    return (element != null ? new SimpleValueWrapper(element.getObjectValue()) : null);
}
// 改用memcachedClient存值
public void put(Object key, Object value) {
    this.cache.put(new Element(key, value));
}
// 擦除delete
public void evict(Object key) {
    this.cache.remove(key);
}
// 清空cache，这个是例如@CacheEvict(value = "notice_cache", allEntries = true)时调用的
public void clear() {
    this.cache.removeAll();
}
</code></pre>

<p>}
```
好了，来写memcachedCache，<strong><em>问题来了</em></strong>：<br/>
1.clear方法，spy的client没有removeAll，clear之类的方法，有个flush是全部清空，服务器N多个cache都会擦掉<br/>
2.@CacheEvict(value = &ldquo;notice_cache&rdquo;, allEntries = true)就是用的clear，“添加个notice都要清掉其他非notice_cache缓存”就很可怕，能不能根据cache名称清除呢？
3.上面两个实际是一个问题，memcached是key-value存储，所以要对key进行分组，采用一个集合保存key，然后将实际的key-value存入<br/>
常用的集合数据类型如list，map，set它也支持，考虑到key的字符限制和单个value不超过1MB，使用一个set存储一个cache里所有的key能达到2万以上(看key的字节数)，使用压缩存储的更多，同时使用LRU（如LinkedHashMap，将过期的或长期不用的移除），基本满足使用<br/>
标签：<a href="/blog/categories/memcached">memcached</a></p>

<p><strong><em>MemcachedCache</em></strong>：
```java
public class MemcachedCache implements Cache {</p>

<pre><code>// 单个cache存储的key最大数量
private static final int maxElement = 10000;
// 默认过期时间10天
private static final int expire = 10 * 24 * 60 * 60;
private String name;
private MemcachedClient client;
// 存储key的集合，使用LinkedHashMap实现
private KeySet keys;

public MemcachedCache() {}

public MemcachedCache(String name, MemcachedClient client) {
    this.name = name;
    this.keys = new KeySet(maxElement);
    this.client = client;
}

public String getName() {
    return this.name;
}

public Object getNativeCache() {
    return this.client;
}
// ckey是key+cacheName作为前缀，也是最终存入缓存的key
public ValueWrapper get(Object key) {
    String ckey = toStringWithCacheName(key);
    if (keys.containsKey(ckey)) {
        Object value = client.get(ckey);
        return value != null ? new SimpleValueWrapper(value) : null;
    } else {
        return null;
    }
}
// 将ckey加入key集合并将ckey-value存入缓存
public void put(Object key, Object value) {
    String ckey = toStringWithCacheName(key);
    keys.add(ckey);
    client.set(ckey, expire, value);
}
// 从keys集合清除ckey，并从缓存清除
public void evict(Object key) {
    String ckey = toStringWithCacheName(key);
    keys.remove(ckey);
    client.delete(ckey);
}

private String toStringWithCacheName(Object obj) {
    return name + "." + String.valueOf(obj);
}
// 遍历清除
public void clear() {
    for (String ckey : keys.keySet()) {
        client.delete(ckey);
    }
    keys.clear();
}

public MemcachedClient getClient() {
    return this.client;
}

public void setClient(MemcachedClient client) {
    this.client = client;
}

public Map&lt;String, String&gt; getKeys() {
    return this.keys;
}
</code></pre>

<p>}
<code>
这里keys也可以使用cacheName作为key存入缓存，就需要在put,evict,clear方法里使用</code>client.replace(name, expire, keys);```保持更新，但好像成本多了，收益不大</p>

<p><strong><em>KeySet</em></strong>继承LinkedHashMap，为了使用removeEldestEntry，满了移除最旧元素，保持initSize:
```java
public class KeySet extends LinkedHashMap&lt;String, String> {</p>

<pre><code>private int max;

public KeySet(int initSize) {
    super(initSize, 0.75F, true);
    this.max = initSize;
}

public void add(String key) {
    super.put(key, null);
}

public boolean removeEldestEntry(Map.Entry&lt;String, String&gt; eldest) {
    return size() &gt; this.max;
}
</code></pre>

<p>}
```</p>

<h4>3. 线程安全</h4>

<p>HashSet\HashMap都不是线程安全的，例如<a href="http://coolshell.cn/articles/9606.html">Java HashMap的死循环</a>;<br/>
安全的如Collections.synchronizedMap和ConcurrentHashMap（不允许value为null）；<br/>
两者的区别是锁不同：synchronizedMap使用对象锁，相当于在方法上声明synchronized；ConcurrentHashMap比较复杂，在segment上加锁，将范围控制的很小，因而并发性能就高；<br/>
这里使用LinkedHashMap，ConcurrentHashMap不好包装，synchronizedMap效率低，不如加个ReentrantLock，或者使用读写锁ReentrantReadWriteLock(但这篇文章介绍了读写锁可能存在问题：<a href="http://skydream.iteye.com/blog/1562880">小心LinkedHashMap的get()方法</a>)：<br/>
```java</p>

<pre><code>lock.lock();
try {
    client.set(...);
} finally {
    lock.unlock();
} 
</code></pre>

<p><code>
下面是HashMap占用cpu 100% bug的代码：
</code>java
public class MapTest {</p>

<pre><code>public static void main(String[] args) throws InterruptedException {
    Map&lt;String, String&gt; temp = new HashMap&lt;&gt;(2);
    final Map&lt;String, String&gt; map = temp;
    //      final Map&lt;String, String&gt; map = new LinkedHashMap&lt;&gt;(temp);
    //      final Map&lt;String, String&gt; map = new ConcurrentHashMap&lt;&gt;(temp);
    //      final Map&lt;String, String&gt; map = Collections.synchronizedMap(temp);

    Thread t = new Thread(new Runnable() {
        public void run() {
            for (int i = 0; i &lt; 10000; i++) {
                new Thread(new Runnable() {
                    public void run() {
                        map.put(UUID.randomUUID().toString(), "");
                    }
                }).start();
            }
        }
    });
    t.start();
    t.join();
}
</code></pre>

<p>}
```</p>

<h4>4. 测试Spring 4.0.x Cache</h4>

<p>以上3.2.x使用正常，4.0版本改动了key生成器，所以测试下</p>

<p>未完待续</p>
]]></content>
  </entry>
  
</feed>
